#pragma kernel EdgeDetection

struct EdgeVertex {
    int2 position;
    int2 neighbourA;
    int2 neighbourB;
    float slope;
    float4 debugstuff;
};

static int2 searchDirections[] = { int2(1, 0), int2(1, 1), int2(0, 1), int2(-1, 1), int2(-1, 0), int2(-1, -1),  int2(0, -1), int2(1, -1) };

AppendStructuredBuffer<EdgeVertex> edgeVertices;
RWTexture2D<float4> inputTexture;

bool IsEdge(uint x, uint y)
{
    if(inputTexture[uint2(x, y)].x < 0.1 && inputTexture[uint2(x - 1, y)].x > 0.1)
        return true;

    if(inputTexture[uint2(x, y)].x < 0.1 && inputTexture[uint2(x + 1, y)].x > 0.1)
        return true;
        
    if(inputTexture[uint2(x, y)].x < 0.1 && inputTexture[uint2(x, y - 1)].x > 0.1)
        return true;

    if(inputTexture[uint2(x, y)].x < 0.1 && inputTexture[uint2(x , y + 1)].x > 0.1)
        return true;

    return false;
}

[numthreads(32,32,1)]
void EdgeDetection(uint3 id : SV_DispatchThreadID)
{
    if(IsEdge(id.x, id.y))
    {
        int x = id.x;
        int y = id.y;
        uint sampleSize = 25;
        int2 neighbours[25];
        uint neighbourIndex = 0;

        //Find nearest neighbour edge points
        for(int i = 0; i < searchDirections.Length; i++)
        {
            int2 testPosition = int2(x + searchDirections[i].x, y + searchDirections[i].y);
        
            if(IsEdge(testPosition.x, testPosition.y))
            {
                neighbours[neighbourIndex] = testPosition;
                neighbourIndex += 1;

                if(neighbourIndex == 2)
                    break;
            }
        }

        //From these neighbours find all their unique neighbour edge points
        /*for(int n = 0; n < 2; n++)
        {
            int iterations = 0;
            int failIterations = 0;
            int directionIndex = 0;

            x = neighbours[n].x;
            y = neighbours[n].y;

            int lastX = id.x;
            int lastY = id.y;
            
            while(iterations < (sampleSize / 2 - 2) && failIterations < 10)
            {
                int2 dir = searchDirections[directionIndex];
                int testX = x + dir.x;
                int testY = y + dir.y;

                if(testX != lastX && testY != lastY && IsEdge(testX, testY))
                {
                    lastX = x;
                    lastY = y;
                    x = testX;
                    y = testY;
                    iterations += 1;
                    neighbours[neighbourIndex] = int2(testX, testY);
                    neighbourIndex += 1;
                    failIterations = 0;
                } else {
                    directionIndex += 1;

                    if(directionIndex > searchDirections.Length - 1)
                        directionIndex = 0;

                    failIterations += 1;
                }
            }
        }*/

        //Having adjacent points on the edge calculate the slope with linear regression
        /*float meanX = 0.0;
        float meanY = 0.0;

        for(uint j = 0; j < neighbourIndex; j++)
        {
            meanX += float(neighbours[j].x) / float(neighbourIndex);
            meanY += float(neighbours[j].y) / float(neighbourIndex);
        }

        float varianceX = 0.0;
        float covariance = 0.0;

        for(uint k = 0; k < neighbourIndex; k++)
        {
            varianceX += pow(float(neighbours[k].x) - meanX, 2.0);
            //varianceY += pow(float(neighbours[j].y) - meanY, 2);
            covariance += (float(neighbours[k].x) - meanX) * (float(neighbours[k].y) - meanY);
        }*/

        //float slope = covariance / varianceX;

        EdgeVertex v;
        v.position = id.xy;
        v.slope = -1.0;
        v.neighbourA = neighbours[0];
        v.neighbourB = neighbours[1];
        v.debugstuff = float4(0.0, 0.0, 0.0, 0.0);
        edgeVertices.Append(v);
    }
}