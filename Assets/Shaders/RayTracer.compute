#pragma kernel Raytracer

struct LightData {
    float2 position;
};

struct CircleData {
    float2 center;
    float radius;
};

struct BoxData {
    float2 center;
    float2 extents;
};

struct EdgeVertex {
    float2 position;
    float2 roundedPos;
    int shapeIndex;
};

static int2 searchDirections[] = { int2(1, 0), int2(0, 1), int2(-1, 0), int2(0, -1) };

RWStructuredBuffer<LightData> lights;
RWStructuredBuffer<CircleData> circles;
RWStructuredBuffer<BoxData> boxes;

RWTexture2D<float4> destTexture;
RWTexture2D<float2> edgePositionTexture;
AppendStructuredBuffer<EdgeVertex> edgeVertices;

static float EPSILON = 0.00001;

int TestRaySphere(float2 p, float2 dir, float2 center, float radius)
{
        float2 m = p - center;
        float b = dot(m, dir);
        float c = dot(m, m) - radius * radius;

        if(c > 0.0 && b > 0.0) return 0;

        float disc = b * b - c;

        if(disc < 0.0) return 0;

        return 1;
}

int TestRayBox(float2 p0, float2 p1, float2 boxMin, float2 boxMax)
{
    float2 e = boxMax - boxMin; //Extents
    float2 d = p1 - p0;  //Segment half length vector
    float2 m = p0 + p1 - boxMin - boxMax; //Segment midpoint (some length)

    //Try world coor axes as seperating axes
    float adx = abs(d.x);
    if(abs(m.x) > e.x + adx) return 0;

    float ady = abs(d.y);
    if(abs(m.y) > e.y + ady) return 0;
    
    // Add in an epsilon term to counteract arithmetic errors when segment is
    // (near) parallel to a coordinate axis
    adx += EPSILON; ady += EPSILON;
    
    // Try cross products of segment direction vector with coordinate axes
    if (abs(m.x * d.y - m.y * d.x) > e.x * ady + e.y * adx) return 0;

    //if(p1.y < boxMin.y) return 0;

    return 1;
}

[numthreads(32,32,1)]
void Raytracer (uint3 id : SV_DispatchThreadID)
{
    int intersections = 0;
    destTexture[id.xy] = float4(1.0, 1.0, 1.0, 0.0);

    for(int i = 0; i < lights.Length; i++)
    {
        float x1 = id.x;
        float y1 = id.y;

        float2 lightPos = lights[i].position;
        float x2 = lightPos.x;
        float y2 = lightPos.y;
        
        float2 direction = float2(x2 - x1, y2 - y1);
        float dist = sqrt(pow(direction.x, 2) + pow(direction.y, 2));
        float2 directionNormalized = direction / dist;

        for(int j = 0; j < circles.Length; j++)
        {
            CircleData circle = circles[j];   
            //intersections += TestRaySphere(id.xy, directionNormalized, circle.center, circle.radius);

            if(intersections > 0)
            {
            }
        }

        for(int k = 0; k < boxes.Length; k++)
        {
            float2 boxCenter = boxes[k].center;
            float2 extents = boxes[k].extents;
            float2 boxMin = boxCenter - extents;
            float2 boxMax = boxCenter + extents;

            intersections = TestRayBox(lightPos, float2(x1, y1), boxMin, boxMax);

            if(intersections > 0)
            {
                //Find more accurate value rather than rounded off value
                float2 dir = float2(0.0, 0.0);
                
                if(TestRayBox(lightPos, float2(x1 + 1.0, y1), boxMin, boxMax) == 0)
                {
                    dir.x = 1.0;
                } 
                else if(TestRayBox(lightPos, float2(x1 - 1.0, y1), boxMin, boxMax) == 0)
                {
                    dir.x = -1.0;
                }

                if(TestRayBox(lightPos, float2(x1, y1 + 1.0), boxMin, boxMax) == 0)
                {
                    dir.y = 1.0;
                }
                else if(TestRayBox(lightPos, float2(x1, y1 - 1.0), boxMin, boxMax) == 0)
                {                
                    dir.y = -1.0;
                }

                if(abs(dir.x) > 0.0 || abs(dir.y) > 0.0)
                {
                    bool intersecting = true; 
                    float stepSize = 0.001;
                    float steps = 0.0;

                    while(intersecting == true && steps < 1000.0)
                    {
                        steps += 1.0;
                        intersecting = TestRayBox(lightPos, float2(x1 + stepSize * steps * dir.x, y1 + stepSize * steps * dir.y), boxMin, boxMax) > 0;
                    }

                    float2 vertex = float2(x1 + stepSize * steps * dir.x, y1 + stepSize * steps * dir.y);

                    EdgeVertex v;
                    v.position = vertex;
                    v.roundedPos = float2(x1, y1);
                    v.shapeIndex = i * lights.Length + k;
                    edgeVertices.Append(v);
                }

                if(intersections > 0)
                {
                    destTexture[id.xy] *= float4(0.1, 0.1, 0.1, 0.5);
                }
            }
        }
    }
}