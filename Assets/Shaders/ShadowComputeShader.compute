#pragma kernel ShadowComputeShader

struct LightData {
    float angle;
    float range;
    float intensity;
    float4 color;
    float2 position;
};

struct CircleData {
    float2 center;
    float radius;
};

struct BoxData {
    float2 center;
    float2 extents;
};

struct EdgeVertex {
    float2 position;
    float2 roundedPos;
    int shapeIndex;
};

static int2 searchDirections[] = { int2(1, 0), int2(0, 1), int2(-1, 0), int2(0, -1) };

RWStructuredBuffer<LightData> lights;
RWStructuredBuffer<CircleData> circles;
RWStructuredBuffer<BoxData> boxes;

RWTexture2D<float4> destTexture;
RWTexture2D<float2> edgePositionTexture;
AppendStructuredBuffer<EdgeVertex> edgeVertices;

static float EPSILON = 0.00001;
static float PI = 3.14;

int TestRaySphere(float2 p, float2 dir, float2 center, float radius)
{
        float2 m = p - center;
        float b = dot(m, dir);
        float c = dot(m, m) - radius * radius;

        if(c > 0.0 && b > 0.0) return 0;

        float disc = b * b - c;

        if(disc < 0.0) return 0;

        return 1;
}

int TestRayBox(float2 p0, float2 p1, float2 boxMin, float2 boxMax)
{
    float2 e = boxMax - boxMin; //Extents
    float2 d = p1 - p0;  //Segment half length vector
    float2 m = p0 + p1 - boxMin - boxMax; //Segment midpoint (some length)

    //Try world coor axes as seperating axes
    float adx = abs(d.x);
    if(abs(m.x) > e.x + adx) return 0;

    float ady = abs(d.y);
    if(abs(m.y) > e.y + ady) return 0;
    
    // Add in an epsilon term to counteract arithmetic errors when segment is
    // (near) parallel to a coordinate axis
    adx += EPSILON; ady += EPSILON;
    
    // Try cross products of segment direction vector with coordinate axes
    if (abs(m.x * d.y - m.y * d.x) > e.x * ady + e.y * adx) return 0;

    //if(p1.y < boxMin.y) return 0;

    return 1;
}

[numthreads(32,32,1)]
void ShadowComputeShader (uint3 id : SV_DispatchThreadID)
{
    int totalIntersections = 0;
    destTexture[id.xy] = float4(0.0, 0.0, 0.0, 0.0);

    for(int i = 0; i < lights.Length; i++)
    {
        float x1 = id.x;
        float y1 = id.y;

        float2 lightPos = lights[i].position;
        float lightAngle = lights[i].angle;
        float x2 = lightPos.x;
        float y2 = lightPos.y;
        
        float2 direction = float2(x2 - x1, y2 - y1);
        float angle = fmod(atan2(direction.y, -direction.x) + lightAngle + 2 * PI, 2 * PI);
        float dist = sqrt(pow(direction.x, 2) + pow(direction.y, 2));
        float2 directionNormalized = direction / dist;

        float maxDistance = lights[i].range;

        if(dist > maxDistance)
            continue;

        for(int j = 0; j < circles.Length; j++)
        {
            CircleData circle = circles[j];   
            //intersections += TestRaySphere(id.xy, directionNormalized, circle.center, circle.radius);

        }

        for(int k = 0; k < boxes.Length; k++)
        {
            float2 boxCenter = boxes[k].center;
            float2 extents = boxes[k].extents;
            float2 boxMin = boxCenter - extents;
            float2 boxMax = boxCenter + extents;

            int intersections = TestRayBox(lightPos, float2(x1, y1), boxMin, boxMax);
            totalIntersections += intersections;

            if(intersections > 0)
            {
                //Find more accurate value rather than rounded off value
                float2 dir = float2(0.0, 0.0);
                
                if(TestRayBox(lightPos, float2(x1 + 1.0, y1), boxMin, boxMax) == 0)
                {
                    dir.x = 1.0;
                } 
                else if(TestRayBox(lightPos, float2(x1 - 1.0, y1), boxMin, boxMax) == 0)
                {
                    dir.x = -1.0;
                }

                if(TestRayBox(lightPos, float2(x1, y1 + 1.0), boxMin, boxMax) == 0)
                {
                    dir.y = 1.0;
                }
                else if(TestRayBox(lightPos, float2(x1, y1 - 1.0), boxMin, boxMax) == 0)
                {                
                    dir.y = -1.0;
                }

                bool isEdgeVertex = false;
                float2 vertex;

                if(abs(dir.x) > 0.0 || abs(dir.y) > 0.0)
                {
                    bool intersecting = true; 
                    float stepSize = 0.001;
                    float steps = 0.0;

                    while(intersecting == true && steps < 1000.0)
                    {
                        steps += 1.0;
                        intersecting = TestRayBox(lightPos, float2(x1 + stepSize * steps * dir.x, y1 + stepSize * steps * dir.y), boxMin, boxMax) > 0;
                    }

                    vertex = float2(x1 + stepSize * steps * dir.x, y1 + stepSize * steps * dir.y);
                    isEdgeVertex = true;
                }

                if(round(dist) == round(maxDistance))
                {
                    isEdgeVertex = true;
                    vertex = float2(x2 - directionNormalized.x * maxDistance, y2 - directionNormalized.y * maxDistance);
                }

                if(isEdgeVertex)
                {
                    EdgeVertex v;
                    v.position = vertex;
                    v.roundedPos = float2(x1, y1);
                    v.shapeIndex = i * max(lights.Length, boxes.Length) + k;
                    edgeVertices.Append(v);
                }
            }
        }

        if(totalIntersections > 0)
        {
            float attenuation = 1.0;//(1.0 / (pow(dist / maxDistance, 2)) - 1.0);
            destTexture[id.xy] *= float4(0.0, 0.0, 0.0, 1.0);
            destTexture[id.xy] += float4(0.0, 0.0, 0.0, 1.0 * min(1.0, attenuation));
            destTexture[id.xy] *= float4(0.25, 0.25, 0.25, 0.5);
        } else {
            /*float constantAtt = 1.0;
            float linearAtt = 0.0;
            float quadraticAtt = 0.0;
            float attenuation = (1.0 / (constantAtt + linearAtt * dist / maxDistance + quadraticAtt * ((dist/maxDistance) * (dist / maxDistance))));
            destTexture[id.xy] += lights[i].color * lights[i].intensity * attenuation;*/
        }
    }
}